# Модуль 3. Задание 07 (Очереди сообщений POSIX, 3 балла).
    Написать две программы, использующие одну очередь сообщений для двухстороннего взаимодействия (персональный чат)
    Сообщения отправляются по очереди (пинг-понг).
    Для завершения обмена предусмотреть отправку данных с заранее известным приоритетом.

# Реализация
-   Логика программы похожа на предыдущую. Так же состоит из двух частей: отправителя и получателя, но реализована уже с использованием очереди сообщений POSIX. 
-   С помощью функции `mq_open` очередь создаётся, или открывается. До этого объявляется дескриптор очереди и структура для хранения её атрибутов(специальные флаги, макс. кол-во сообщений в очереди, макс. размер сообщения и т.д.).
-   Инициатором диалога выступает `sender.c`. Сообщение сохраняется в `msg.text`, с `msg_type` = 1 для идентификации типа сообщения, и отправляется в очередь через `mq_send`. Ответ получает через `mq_receive`. Аналогично все работает и для `receiver.c`, только он сначала "ожидает" сообщение, и, отправляя ответ, устанавливает `msg_type` в значение 2.
-   Программа завершается, если один из пользователей введет "exit". Поэтому в программах происходит проверка и после отправления сообщения, и после получения. Если такое сообщение было получено кем-либо, очередь закрывается при помощи функции `mq_close`, а затем удаляется через `mq_unlink`. 
-   На данном этапе есть ошибка, которую я пока не придумала как решить. Так как оба участника могут завершить диалог, в обеих программах есть функции закрытия и удаления очереди. Удалить очередь нельзя, не закрыв её у обоих участников, поэтому удаление тоже пока происходит у обоих. Из-за этого закрытие и удаление очереди у инициатора завершения диалога происходит успешно, а у другого участника очередь закрывается и повторно вызывается функция удаления. И хотя очередь уже не существует функция отрабатывает, но с ошибкой. В общем, в будущей версии нужно избавиться от повторного вызова функции удаления очереди.